---
layout: post
title: 嵌入式软件C/C++/OS/驱动程序开发笔记
date: 2024-01-19 20:33:04
tags: 
    - C/C++
categories: 
    - 嵌入式
---

包含C/C++，操作系统，linux内核/驱动，嵌入式等一系列开发经验和知识总结。
<!-- more -->

- [C语言](#c语言)
  - [程序编译的过程？](#程序编译的过程)
  - [C和C++的区别？](#c和c的区别)
  - [指针](#指针)
    - [指针和引用的区别？](#指针和引用的区别)
    - [引用占用内存空间吗？](#引用占用内存空间吗)
    - [请你来说一下函数指针](#请你来说一下函数指针)
    - [请你回答一下野指针是什么？](#请你回答一下野指针是什么)
    - [请回答一下数组和指针的区别](#请回答一下数组和指针的区别)
    - [指针数组和数组指针的区别](#指针数组和数组指针的区别)
  - [函数](#函数)
    - [int fun() 和 int fun(void)的区别?](#int-fun-和-int-funvoid的区别)
    - [函数调用的过程？](#函数调用的过程)
  - [关键字](#关键字)
    - [static有什么用途](#static有什么用途)
    - [类的静态成员变量和静态成员函数各有哪些特性？](#类的静态成员变量和静态成员函数各有哪些特性)
    - [const 有什么用途](#const-有什么用途)
    - [在C中用const能定义真正意义上的常量吗？C++中的const呢？](#在c中用const能定义真正意义上的常量吗c中的const呢)
    - [请说一下extern关键字的作用？](#请说一下extern关键字的作用)
  - [预处理](#预处理)
    - [请你来回答一下include头文件的顺序以及双引号" "和尖括号\< \> 的区别](#请你来回答一下include头文件的顺序以及双引号-和尖括号--的区别)
    - [宏和内联（inline）函数的比较？](#宏和内联inline函数的比较)
    - [头文件中的ifndef/define/endif是干什么用的? 该用法和program once的区别？](#头文件中的ifndefdefineendif是干什么用的-该用法和program-once的区别)
  - [内存](#内存)
    - [堆和栈的区别？](#堆和栈的区别)
    - [堆和自由存储区的区别？](#堆和自由存储区的区别)
    - [C++中有了malloc / free , 为什么还需要 new / delete？](#c中有了malloc--free--为什么还需要-new--delete)
    - [什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？](#什么是内存泄漏面对内存泄漏和指针越界你有哪些方法你通常采用哪些方法来避免和减少这类错误)
- [操作系统](#操作系统)
  - [基本特征](#基本特征)
  - [基本功能](#基本功能)
  - [大内核和微内核](#大内核和微内核)
  - [中断分类](#中断分类)
  - [进程管理](#进程管理)
    - [区别](#区别)
    - [进程状态的切换](#进程状态的切换)
    - [进程调度算法](#进程调度算法)
    - [进程同步](#进程同步)
    - [经典同步问题](#经典同步问题)
    - [进程通信](#进程通信)
  - [死锁](#死锁)
    - [必要条件](#必要条件)
    - [处理方法](#处理方法)
      - [鸵鸟策略](#鸵鸟策略)
      - [死锁恢复](#死锁恢复)
      - [死锁预防](#死锁预防)
      - [死锁避免](#死锁避免)
  - [内存管理](#内存管理)
    - [虚拟内存](#虚拟内存)
    - [分页系统地址映射](#分页系统地址映射)
    - [页面置换算法](#页面置换算法)
    - [分段](#分段)
    - [段页式](#段页式)
    - [分页与分段的比较](#分页与分段的比较)
  - [设备管理](#设备管理)
    - [磁盘结构](#磁盘结构)
    - [磁盘调度算法](#磁盘调度算法)
      - [先来先服务FCFS, First Come First Serve](#先来先服务fcfs-first-come-first-serve)
      - [最短寻道时间优先SSTF, Shortest Seek Time First](#最短寻道时间优先sstf-shortest-seek-time-first)
      - [电梯算法SCAN](#电梯算法scan)
  - [链接](#链接)
    - [编译系统](#编译系统)
    - [静态链接](#静态链接)
    - [目标文件](#目标文件)
    - [动态链接](#动态链接)
- [想成为嵌入式程序员应知道的0x10个基本问题](#想成为嵌入式程序员应知道的0x10个基本问题)
  - [预处理器（Preprocessor）](#预处理器preprocessor)
  - [死循环（Infinite loops）](#死循环infinite-loops)
  - [数据声明（Data declarations）](#数据声明data-declarations)
  - [Static](#static)
  - [Const](#const)
  - [Volatile](#volatile)
  - [位操作（Bit manipulation）](#位操作bit-manipulation)
  - [访问固定的内存位置（Accessing fixed memory locations）](#访问固定的内存位置accessing-fixed-memory-locations)
  - [中断（Interrupts）](#中断interrupts)
  - [代码例子（Code examples）](#代码例子code-examples)
  - [动态内存分配（Dynamic memory allocation）](#动态内存分配dynamic-memory-allocation)
  - [Typedef](#typedef)
  - [晦涩的语法](#晦涩的语法)

## C语言

### 程序编译的过程？

- 程序编译的过程中就是将用户的文本形式的源代码(c/c++)转化成计算机可以直接执行的机器代码的过程。主要经过四个过程：预处理、编译、汇编和链接。具体示例如下。
- 一个hello.c的c语言程序如下。
  - 预处理阶段：hello.c-->hello.i
  - 编译阶段：hello.i-->hello.s
  - 汇编阶段：hello.s-->hello.o
  - 链接阶段：hello.o-->hello

### C和C++的区别？

- C++是C的超集;
- C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制），而对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。


### 指针

#### 指针和引用的区别？

相同点：

- 都是地址的概念；
- 都是“指向”一块内存。指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名；
- 引用在内部实现其实是借助指针来实现的，一些场合下引用可以替代指针，比如作为函数形参。

不同点：

- 指针是一个实体，而引用(看起来，这点很重要)仅是个别名；
- 引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
- 引用不能为空，指针可以为空；
- “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
- 指针和引用的自增(++)运算意义不一样；
- 引用是类型安全的，而指针不是 (引用比指针多了类型检查)
- 引用具有更好的可读性和实用性。

C++补充

- 引用
  - 引用就是 C++对 C语言的重要扩充。引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。
  - 引用的声明方法：类型标识符 &引用名=目标变量名；
  - 引用引入了对象的一个同义词。定义引用的表示方法与定义指针相似，只是用&代替了*。
  - 引用使用注意事项：
    - 引用必须被初始化；
    - 引用不能改变绑定的对象；

- 指针
  - 指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。
  - 指针使用注意事项：
    - 初始化时要置空；
    - 使用时要考虑指向对象边界问题；
    - 不能对未初始化的指针取值或赋值；
    - 释放时要置空；
    - 如果返回动态分配内存或对象，必须使用指针；
  
区别：

- 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间；
- 使用 sizeof 看一个指针的大小是 4，而引用则是被引用对象的大小；
- 指针可以被初始化为 NULL，而引用必须被初始化且必须是一个已有对象的引用；
- 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；
- 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；
- 指针可以有多级指针（**p），而引用至多一级；
- 指针和引用使用自增运算符的意义不一样；（指针是指向下一个空间，引用时引用的变量值加1）
- 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。

#### 引用占用内存空间吗？

如下代码中对引用取地址，其实是取的引用所对应的内存空间的地址。这个现象让人觉得引用好像并非一个实体。但是引用是占用内存空间的，而且其占用的内存和指针一样，因为引用的内部实现就是通过指针来完成的。
比如 Type& name； <===> Type* const name。

```cpp
int main(void)
{
        int a = 8;
        const int &b = a;
        int *p = &a;
        *p = 0;
        cout<<a; //output 0
    return 0;
}
```

#### 请你来说一下函数指针

- 定义：函数指针是一个指向函数首地址的指针变量。
C在编译时，每一个函数都有一个人口地址，函数指针指向的就是这个人口地址。有了函数指针，可以通过指针来调用函数。就向指针数组一样。
- 用途：
调用函数和做函数的参数，比如回调函数。
- 示例：

```CPP
char* fun(char * p) {…};  // 普通函数 fun
char* (*pf)(char * p);     // 函数指针 pf
pf = fun; // 函数指针 pf 指向函数 fun
pf(p);    // 通过函数指针 pf 调用函数 fun
```

#### 请你回答一下野指针是什么？

野指针就是指向一个已释放的内存或者无访问权限的内存区域的指针。

#### 请回答一下数组和指针的区别

指针和数组的主要区别如下：
![](/img/post_pics/c/c_5.png)

#### 指针数组和数组指针的区别

- 数组指针，是指向数组的指针，而指针数组则是指该数组的元素均为指针。
- 数组指针，是指向数组的指针，其本质为指针，形式如下。如`int (*p)[10]`，p即为指向数组的指针，()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。数组指针是指向数组首元素的地址的指针，其本质为指针，可以看成是二级指针。

```cpp
类型名 (*数组标识符)[数组长度]
```

指针数组，在C语言和C++中，数组元素全为指针的数组称为指针数组，其中一维指针数组的定义形式如下。指针数组中每一个元素均为指针，其本质为数组。如`int *p[n]`， `[]`优先级高，先与p结合成为一个数组，再由`int*`说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样`*p=a`; 这里`*p`表示指针数组第一个元素的值，a的首地址的值。

```cpp
类型名 *数组标识符[数组长度]
```

### 函数

#### int fun() 和 int fun(void)的区别?

- 这里考察的是c中的默认类型机制。在c中，int fun() 会解读为返回值为int(即使前面没有int，也是如此，但是在c++中如果没有返回类型将报错)，输入类型和个数没有限制， 而int fun(void)则限制输入类型为一个void。
- 在c++下，这两种情况都会解读为返回int类型，输入void类型。

#### 函数调用的过程？

如下结构的代码，

```cpp
int main(void)
{
  ...
  d = fun(a, b, c);
  cout<<d<<endl;
  ...
  return 0;
}
```

调用fun()的过程大致如下：

- main()
  - 参数拷贝（压栈），注意顺序是从右到左，即c-b-a；
  - 保存d = fun(a, b, c)的下一条指令，即cout<<d<<endl（实际上是这条语句对应的汇编指令的起始位置）;
  - 跳转到fun()函数，注意，到目前为止，这些都是在main()中进行的；
- fun()
  - 移动ebp、esp形成新的栈帧结构;
  - 压栈（push）形成临时变量并执行相关操作;
  - return一个值;
  - 出栈（pop）;
  - 恢复main函数的栈帧结构;
  - 返回main函数;
- main()

### 关键字

#### static有什么用途

- 全局静态变量
  - 在全局变量前加上关键字 static，全局变量就定义成一个全局静态变量。
  - 内存中位置：静态存储区，在整个程序运行期间一直存在。
  - 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
  - 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

- 局部静态变量
  - 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。
  - 内存中的位置：静态存储区
  - 初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
  - 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
- 静态函数
  - 在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
  - 函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；
  - 注意：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
- 类的静态成员
  - 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。
- 类的静态函数
  - 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。
  
在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。
从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);
简洁回答：（推荐）

- 加了static 关键字的全局变量只能在本文件中使用。
- 例如在 a.c 中定义了`static int a=10`;那么在 b.c 中用extern int a 是拿不到 a 的值得，a 的作用域只在 a.c 中。
- static定义的静态局部变量分配在数据段上，普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。
- 对一个类中成员变量和成员函数来说，加了 static 关键字，则此变量/函数就没有了 this 指针了，必须通过类名才能访问

#### 类的静态成员变量和静态成员函数各有哪些特性？

- 静态成员变量
  - 静态成员变量需要在类内声明（加static），在类外初始化（不能加static），如下例所示；
  - 静态成员变量在类外单独分配存储空间，位于全局数据区，因此静态成员变量的生命周期不依赖于类的某个对象，而是所有类的对象共享静态成员变量；
  - 可以通过对象名直接访问公有静态成员变量；
  - 可以通过类名直接调用公有静态成员变量，即不需要通过对象，这一点是普通成员变量所不具备的。
  
```cpp
class example{
private:
static int m_int; //static成员变量
};

int example::m_int = 0; //没有static

cout<<example::m_int; //可以直接通过类名调用静态成员变量
```

- 静态成员函数
  - 静态成员函数是类所共享的；
  - 静态成员函数可以访问静态成员变量，但是不能直接访问普通成员变量（需要通过对象来访问）；需要注意的是普通成员函数既可以访问普通成员变量，也可以访问静态成员变量；
  - 可以通过对象名直接访问公有静态成员函数；
  - 可以通过类名直接调用公有静态成员函数，即不需要通过对象，这一点是普通成员函数所不具备的。
  
```cpp
class example{
private:
static int m_int_s; //static成员变量
int m_int;
static int getI() //静态成员函数在普通成员函数前加static即可
{
  return m_int_s; //如果返回m_int则报错，但是可以return d.m_int是合法的
}
};

cout<<example::getI(); //可以直接通过类名调用静态成员变量
```

#### const 有什么用途

![](/img/post_pics/c/c_4.png)

- 定义只读变量，或者常量（只读变量和常量的区别参考下面一条）;
- 修饰函数的参数和函数的返回值;
- 修饰函数的定义体，这里的函数为类的成员函数，被const修饰的成员函数代表不能修改成员变量的值，因此const成员函数只能调用const成员函数；
- 只读对象。只读对象只能调用const成员函数。
  
```cpp
class Screen {
public:
const char cha； //const成员变量
char get() const; //const成员函数
};

const Screen screen； //只读对象
```

#### 在C中用const能定义真正意义上的常量吗？C++中的const呢？

不能。c中的const仅仅是从编译层来限定，不允许对const 变量进行赋值操作，在运行期是无效的，所以并非是真正的常量（比如通过指针对const变量是可以修改值的），但是c++中是有区别的，c++在编译时会把const常量加入符号表，以后（仍然在编译期）遇到这个变量会从符号表中查找，所以在C++中是不可能修改到const变量的。

- c中的局部const常量存储在栈空间，全局const常量存在只读存储区，所以全局const常量也是无法修改的，它是一个只读变量。
- 这里需要说明的是，常量并非仅仅是不可修改，而是相对于变量，它的值在编译期已经决定，而不是在运行时决定。
- c++中的const 和宏定义是有区别的，宏是在预编译期直接进行文本替换，而const发生在编译期，是可以进行类型检查和作用域检查的。
- **c语言中只有enum可以实现真正的常量。**
- c++中只有用字面量初始化的const常量会被加入符号表，而变量初始化的const常量依然只是只读变量。
- c++中const成员为只读变量，可以通过指针修改const成员的值，另外const成员变量只能在初始化列表中进行初始化。
  
下面我们通过代码来看看区别。同样一段代码，在c编译器下，打印结果为*pa = 4， 4；在c++编译下打印的结果为*pa = 4， 8

```cpp
int main(void)
{
    const int a = 8;
    int *pa = (int *)&a;
    *pa = 4;
    printf("*pa = %d, a = %d", *pa, a);
    return 0;
}
```

另外值得一说的是，由于c++中const常量的值在编译期就已经决定，下面的做法是OK的，但是c中是编译通不过的。

```cpp
int main(void)
{
    const int a = 8;
    const int b = 2;
    int array[a+b] = {0};
    return 0;
}
```

#### 请说一下extern关键字的作用？

C++调用 C函数需要 extern C，因为 C 语言没有函数重载。

- extern修饰变量的声明。举例来说，如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。这里需要注意的是，被引用的变量v的链接属性必须是外链接（external）的，也就是说a.c要引用到v，不只是取决于在a.c中声明extern int v，还取决于变量v本身是能够被引用到的。这涉及到c语言的另外一个话题－－变量的作用域。能够被其他模块以extern修饰符引用到的变量通常是全局变量。还有很重要的一点是，extern int v可以放在a.c中的任何地方，比如你可以在a.c中的函数fun定义的开头处声明extern int v，然后就可以引用到变量v了，只不过这样只能在函数fun作用域中引用v罢了，这还是变量作用域的问题。对于这一点来说，很多人使用的时候都心存顾虑。好像extern声明只能用于文件作用域似的。
- extern修饰函数声明。从本质上来讲，变量和函数没有区别。函数名是指向函数二进制块开头处的指针。如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。就像变量的声明一样，extern int fun（int mu）可以放在a.c中任何地方，而不一定非要放在a.c的文件作用域的范围中。对其他模块中函数的引用，最常用的方法是包含这些函数声明的头文件。
- 此外，extern修饰符可用于指示C或者C++函数的调用规范。比如在C++中调用C库函数，就需要在C++程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同。



### 预处理

#### 请你来回答一下include头文件的顺序以及双引号" "和尖括号< > 的区别

对于使用双引号包含的头文件，查找头文件路径的顺序为：

- 当前头文件目录→编译器设置的头文件目录→系统变量指定的头文件路径

对于使用尖括号包含的头文件，查找头文件的路径顺序为：

- 编译器设置的头文件路径→系统变量指定的头文件路径

#### 宏和内联（inline）函数的比较？

- 首先宏是C中引入的一种预处理功能；
- 内联（inline）函数是C++中引用的一个新的关键字；C++中推荐使用内联函数来替代宏代码片段；
- 内联函数将函数体直接扩展到调用内联函数的地方，这样减少了参数压栈，跳转，返回等过程；
- 由于内联发生在编译阶段，所以内联相较宏，是有参数检查和返回值检查的，因此使用起来更为安全；
- 需要注意的是， inline会向编译期提出内联请求，但是是否内联由编译期决定（当然可以通过设置编译器，强制使用内联）；
- 由于内联是一种优化方式，在某些情况下，即使没有显示的声明内联，比如定义在class内部的方法，编译器也可能将其作为内联函数。
- 内联函数不能过于复杂，最初C++限定不能有任何形式的循环，不能有过多的条件判断，不能对函数进行取地址操作等，但是现在的编译器几乎没有什么限制，基本都可以实现内联。

> 宏函数是在程序编译时进行简单的字符替换，而函数是在程序生成后才进行调用，这时会占用开销时间（主程序函数保留现场，在子函数体中需要进行参数的传递--实参传递给形参以及调用完后形参的销毁等步骤），因此宏函数占用的编译时的时间，而函数占用的是执行时的时间。

#### 头文件中的ifndef/define/endif是干什么用的? 该用法和program once的区别？

相同点:它们的作用是防止头文件被重复包含。
不同点:

- ifndef 由语言本身提供支持，但是program once一般由编译器提供支持，也就是说，有可能出现编译器不支持的情况(主要是比较老的编译器)。
- 通常运行速度上 ifndef 一般慢于program once，特别是在大型项目上，区别会比较明显，所以越来越多的编译器开始支持program once。
- fndef 作用于某一段被包含（define 和 endif 之间）的代码， 而 program once 则是针对包含该语句的文件， 这也是为什么 program once 速度更快的原因。
- 如果用 ifndef 包含某一段宏定义，当这个宏名字出现“撞车”时，可能会出现这个宏在程序中提示宏未定义的情况（在编写大型程序时特性需要注意，因为有很多程序员在同时写代码）。相反由于program once 针对整个文件， 因此它不存在宏名字“撞车”的情况， 但是如果某个头文件被多次拷贝，program once 无法保证不被多次包含，因为program once 是从物理上判断是不是同一个头文件，而不是从内容上。

### 内存

#### 堆和栈的区别？

- 堆存放动态分配的对象——即那些在程序运行时分配的对象，比如局部变量，其生存期由程序控制；
- 栈用来保存定义在函数内的非static对象，仅在其定义的程序块运行时才存在；
- 静态内存用来保存static对象，类static数据成员以及定义在任何函数外部的变量，static对象在使用之前分配，程序结束时销毁；
- 栈和静态内存的对象由编译器自动创建和销毁。

#### 堆和自由存储区的区别？

- 总的来说，堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存；自由存储是C++中通过new与delete动态分配和释放对象的抽象概念。他们并不是完全一样。
- 从技术上来说，堆（heap）是C语言和操作系统的术语。堆是操作系统所维护的一块特殊内存，它提供了动态分配的功能，当运行程序调用malloc()时就会从中分配，稍后调用free可把内存交还。
- 而自由存储是C++中通过new和delete动态分配和释放对象的抽象概念，通过new来申请的内存区域可称为自由存储区。基本上，所有的C++编译器默认使用堆来实现自由存储，也即是缺省的全局运算符new和delete也许会按照malloc和free的方式来被实现，这时藉由new运算符分配的对象，说它在堆上也对，说它在自由存储区上也正确。

#### C++中有了malloc / free , 为什么还需要 new / delete？

- malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
- 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
- 由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。最后补充一点体外话，new 在申请内存的时候就可以初始化（如下代码）， 而malloc是不允许的。另外，由于malloc是库函数，需要相应的库支持，因此某些简易的平台可能不支持，但是new就没有这个问题了，因为new是C++语言所自带的运算符。

```cpp
int *p = new int(1);
```

- 特别的，在C++中，如下的代码，用new创建一个对象(new 会触发构造函数， delete会触发析构函数)，但是malloc仅仅申请了一个空间，所以在C++中引入new和delete来支持面向对象。

```cpp
#include <cstdlib>
class Test
{
    ...
}

Test* pn = new Test;
Test* pm = (Test*)malloc(sizeof(Test));
```

#### 什么是内存泄漏？面对内存泄漏和指针越界，你有哪些方法？你通常采用哪些方法来避免和减少这类错误？

用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元即为内存泄露。

- 使用的时候要记得指针的长度.
- malloc的时候得确定在那里free.
- 对指针赋值的时候应该注意被赋值指针需要不需要释放.
- 动态分配内存的指针最好不要再次赋值.
- 在C++中应该优先考虑使用智能指针.


## 操作系统

### 基本特征

- 并发
  - 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。
  - 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。
  - 操作系统通过引入进程和线程，使得程序能够并发运行。

- 共享
  - 共享是指系统中的资源可以被多个并发进程共同使用。
  - 有两种共享方式：互斥共享和同时共享。
  - 互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。

- 虚拟
  - 虚拟技术把一个物理实体转换为多个逻辑实体。
  - 主要有两种虚拟技术：时分复用技术和空分复用技术。
  - 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。
  - 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

- 异步
  - 异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。

### 基本功能

- 进程管理
  - 进程控制、进程同步、进程通信、死锁处理、处理机调度等。

- 内存管理
  - 内存分配、地址映射、内存保护与共享、虚拟内存等。
- 文件管理
  - 文件存储空间的管理、目录管理、文件读写管理和保护等。
- 设备管理
  - 完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。
  - 主要包括缓冲管理、设备分配、设备处理、虛拟设备等。
- 系统调用
  - 如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。
  - Linux 的系统调用主要有以下这些：
  
| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |

### 大内核和微内核

- 大内核
大内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。

- 微内核
由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。

### 中断分类

- 外中断
由CPU执行指令以外的事件引起，如I/O完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

- 异常
由CPU执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。
- 陷入
在用户程序中使用系统调用。

### 进程管理

进程与线程

- 进程
进程是资源分配的基本单位。
进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。
- 线程
线程是独立调度的基本单位。一个进程中可以有多个线程，它们共享进程资源。QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。

#### 区别

- 拥有资源
进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

- 调度
线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- 系统开销
由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
- 通信方面
线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

#### 进程状态的切换

- 就绪状态（ready）：等待被调度

- 运行状态（running）
- 阻塞状态（waiting）：等待资源
  
应该注意以下内容：

- 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
- 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。
  
#### 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

- 批处理系统
批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。
  - `先来先服务 first-come first-serverd（FCFS）`
按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。
  - `短作业优先 shortest job first（SJF）`
按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。
  - `最短剩余时间优先 shortest remaining time next（SRTN）`
按估计剩余时间最短的顺序进行调度。

- 交互式系统
交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。
  - 时间片轮转
将所有就绪进程按`FCFS`的原则排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系：
    - 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
    - 而如果时间片过长，那么实时性就不能得到保证。
  
  - 优先级调度
为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

  - 多级反馈队列
一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。
每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。
可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

- 实时系统
实时系统要求一个请求在一个确定时间内得到响应。分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

#### 进程同步

- 临界区
对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
  
```bash
// entry section
// critical section;
// exit section
```

- 同步与互斥
同步：多个进程按一定顺序执行；
互斥：多个进程在同一时刻只有一个进程能进入临界区。

- 信号量
信号量（Semaphore）是一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作。
down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。
如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。
  
```cpp
typedef int semaphore;
semaphore mutex = 1;
void P1() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
 
void P2() {
    down(&mutex);
    // 临界区
    up(&mutex);
}
```

- 使用信号量实现生产者-消费者问题
问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。
因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。
为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。
注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。
  
```c
#define N 100
typedef int semaphore;
semaphore mutex = 1;
semaphore empty = N;
semaphore full = 0;
 
void producer() {
    while(TRUE) {
        int item = produce_item();
        down(&empty);
        down(&mutex);
        insert_item(item);
        up(&mutex);
        up(&full);
    }
}
 
void consumer() {
    while(TRUE) {
        down(&full);
        down(&mutex);
        int item = remove_item();
        consume_item(item);
        up(&mutex);
        up(&empty);
    }
}
```

- 管程
使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。c语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。
  
```pascal
monitor ProducerConsumer
    integer i;
    condition c;
 
    procedure insert();
    begin
        // ...
    end;
 
    procedure remove();
    begin
        // ...
    end;
end monitor;
```

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。
管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

- 使用管程实现生产者-消费者问题
  
```c
monitor ProducerConsumer
    condition full, empty;
    integer count := 0;
    condition c;
 
    procedure insert(item: integer);
    begin
        if count = N then wait(full);
        insert_item(item);
        count := count + 1;
        if count = 1 then signal(empty);
    end;
 
    function remove: integer;
    begin
        if count = 0 then wait(empty);
        remove = remove_item;
        count := count - 1;
        if count = N -1 then signal(full);
    end;
end monitor;
 
// 生产者客户端
procedure producer
begin
    while true do
    begin
        item = produce_item;
        ProducerConsumer.insert(item);
    end
end;
 
// 消费者客户端
procedure consumer
begin
    while true do
    begin
        item = ProducerConsumer.remove;
        consume_item(item);
    end
end;
```

#### 经典同步问题

生产者和消费者问题前面已经讨论过了。

- 读者-写者问题
允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。
一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。
  
```c
typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;
 
void reader() {
    while(TRUE) {
        down(&count_mutex);
        count++;
        if(count == 1) down(&data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&count_mutex);
        read();
        down(&count_mutex);
        count--;
        if(count == 0) up(&data_mutex);
        up(&count_mutex);
    }
}
 
void writer() {
    while(TRUE) {
        down(&data_mutex);
        write();
        up(&data_mutex);
    }
}
```

以下内容由 @Bandi Yugandhar 提供。
The first case may result Writer to starve. This case favous Writers i.e no writer, once added to the queue, shall be kept waiting longer than absolutely necessary(only when there are readers that entered the queue before the writer).
  
```c
int readcount, writecount;                    //(initial value = 0)
semaphore rmutex, wmutex, readLock, resource; //(initial value = 1)
 
//READER
void reader() {
<ENTRY Section>
  down(&readLock);                //  reader is trying to enter
  down(&rmutex);                  //   lock to increase readcount
  readcount++;                 
  if (readcount == 1)          
    down(&resource);              //if you are the first reader then lock  the resource
  up(&rmutex);                    //release  for other readers
  up(&readLock);                  //Done with trying to access the resource
 
<CRITICAL Section>
//reading is performed
 
<EXIT Section>
  down(&rmutex);                  //reserve exit section - avoids race condition with readers
  readcount--;                    //indicate you're leaving
  if (readcount == 0)             //checks if you are last reader leaving
    up(&resource);                //if last, you must release the locked resource
  up(&rmutex);                    //release exit section for other readers
}
 
//WRITER
void writer() {
  <ENTRY Section>
  down(&wmutex);                  //reserve entry section for writers - avoids race conditions
  writecount++;                   //report yourself as a writer entering
  if (writecount == 1)            //checks if you're first writer
    down(&readLock);              //if you're first, then you must lock the readers out. Prevent them from trying to enter CS
  up(&wmutex);                    //release entry section
 
<CRITICAL Section>
  down(&resource);                //reserve the resource for yourself - prevents other writers from simultaneously editing the shared resource
  //writing is performed
  up(&resource);                  //release file
 
<EXIT Section>
  down(&wmutex);                  //reserve exit section
  writecount--;                   //indicate you're leaving
  if (writecount == 0)            //checks if you're the last writer
    up(&readLock);                //if you're last writer, you must unlock the readers. Allows them to try enter CS for reading
  up(&wmutex);                    //release exit section
}
```

We can observe that every reader is forced to acquire ReadLock. On the otherhand, writers doesn't need to lock individually. Once the first writer locks the ReadLock, it will be released only when there is no writer left in the queue.

From the both cases we observed that either reader or writer has to starve. Below solutionadds the constraint that no thread shall be allowed to starve; that is, the operation of obtaining a lock on the shared data will always terminate in a bounded amount of time.
  
```c
int readCount;                  // init to 0; number of readers currently accessing resource
 
// all semaphores initialised to 1
Semaphore resourceAccess;       // controls access (read/write) to the resource
Semaphore readCountAccess;      // for syncing changes to shared variable readCount
Semaphore serviceQueue;         // FAIRNESS: preserves ordering of requests (signaling must be FIFO)
 
void writer()
{ 
    down(&serviceQueue);           // wait in line to be servicexs
    // <ENTER>
    down(&resourceAccess);         // request exclusive access to resource
    // </ENTER>
    up(&serviceQueue);             // let next in line be serviced
 
    // <WRITE>
    writeResource();               // writing is performed
    // </WRITE>
 
    // <EXIT>
    up(&resourceAccess);           // release resource access for next reader/writer
    // </EXIT>
}
 
void reader()
{ 
    down(&serviceQueue);           // wait in line to be serviced
    down(&readCountAccess);        // request exclusive access to readCount
    // <ENTER>
    if (readCount == 0)            // if there are no readers already reading:
        down(&resourceAccess);     // request resource access for readers (writers blocked)
    readCount++;                   // update count of active readers
    // </ENTER>
    up(&serviceQueue);             // let next in line be serviced
    up(&readCountAccess);          // release access to readCount
 
    // <READ>
    readResource();                // reading is performed
    // </READ>
 
    down(&readCountAccess);        // request exclusive access to readCount
    // <EXIT>
    readCount--;                   // update count of active readers
    if (readCount == 0)            // if there are no readers left:
        up(&resourceAccess);       // release resource access for all
    // </EXIT>
    up(&readCountAccess);          // release access to readCount
}
```

- 哲学家进餐问题
五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。
  
```c
#define N 5
 
void philosopher(int i) {
    while(TRUE) {
        think();
        take(i);       // 拿起左边的筷子
        take((i+1)%N); // 拿起右边的筷子
        eat();
        put(i);
        put((i+1)%N);
    }
}
```

为了防止死锁的发生，可以设置两个条件：

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。
  
```c
#define N 5
#define LEFT (i + N - 1) % N // 左邻居
#define RIGHT (i + 1) % N    // 右邻居
#define THINKING 0
#define HUNGRY   1
#define EATING   2
typedef int semaphore;
int state[N];                // 跟踪每个哲学家的状态
semaphore mutex = 1;         // 临界区的互斥
semaphore s[N];              // 每个哲学家一个信号量
 
void philosopher(int i) {
    while(TRUE) {
        think();
        take_two(i);
        eat();
        put_two(i);
    }
}
 
void take_two(int i) {
    down(&mutex);
    state[i] = HUNGRY;
    test(i);
    up(&mutex);
    down(&s[i]);
}
 
void put_two(i) {
    down(&mutex);
    state[i] = THINKING;
    test(LEFT);
    test(RIGHT);
    up(&mutex);
}
 
void test(i) {         // 尝试拿起两把筷子
    if(state[i] == HUNGRY && state[LEFT] != EATING && state[RIGHT] !=EATING) {
        state[i] = EATING;
        up(&s[i]);
    }
}
```
  
#### 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：进程同步：控制多个进程按一定顺序执行；进程通信：进程间传输信息。
进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

- 管道
管道是通过调用 pipe 函数创建的，`fd[0]`用于读，`fd[1]`用于写。
  
```c
#include <unistd.h>
int pipe(int fd[2]);
```

它具有以下限制：只支持半双工通信（单向交替传输）；只能在父子进程中使用。
  
- FIFO
也称为命名管道，去除了管道只能在父子进程中使用的限制。
  
```c
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。

- 消息队列
相比于 FIFO，消息队列具有以下优点：
  - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
  - 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；
  - 读进程可以根据消息类型有选择地接收消息，而不像FIFO那样只能默认地接收。

- 信号量
它是一个计数器，用于为多个进程提供对共享数据对象的访问。

- 共享存储
允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。
需要使用信号量用来同步对共享存储的访问。
多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。

- 套接字
与其它通信机制不同的是，它可用于不同机器间的进程通信。

### 死锁

#### 必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。

- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

#### 处理方法

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防
- 死锁避免
  
##### 鸵鸟策略

把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。
死锁检测与死锁恢复
不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

- 每种类型一个资源的死锁检测
每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。
- 每种类型多个资源的死锁检测
每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。如果没有这样一个进程，算法终止。
  
##### 死锁恢复

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复
  
##### 死锁预防

在程序运行之前预防发生死锁。

- 破坏互斥条件
例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。
- 破坏占有和等待条件
一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。
- 破坏不可抢占条件
- 破坏环路等待
给资源统一编号，进程只能按编号顺序来请求资源。
  
##### 死锁避免

在程序运行时避免发生死锁。

- 安全状态
  - 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。
- 单个资源的银行家算法
- 多个资源的银行家算法
  
### 内存管理

#### 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。
为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。
从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。
![](/img/post_pics/c/1.png)

#### 分页系统地址映射

内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。
一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。
下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。
![](/img/post_pics/c/2.png)

#### 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。
页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

- 最佳OPT, Optimal replacement algorithm
  - 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。
  - 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。
  - 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：
  - 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。

- 最近最久未使用LRU, Least Recently Used
  - 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。
  - 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
  - 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。

- 最近未使用NRU, Not Recently Used
每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

>R=0，M=0
R=0，M=1
R=1，M=0
R=1，M=1
  
当发生缺页中断时，NRU算法随机地从类编号最小的非空类中挑选一个页面将它换出。
NRU优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

- 先进先出FIFO, First In First Out
选择换出的页面是最先进入的页面。该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

- 第二次机会算法
  - FIFO算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：
    - 当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

- 时钟Clock
第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

#### 分段

虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。
下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。
![](/img/post_pics/c/3.png)
分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。
![](/img/post_pics/c/4.png)

#### 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

#### 分页与分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。

- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
  
### 设备管理

#### 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；

- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

#### 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 主旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 主寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 主实际的数据传输时间
  
其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

##### 先来先服务FCFS, First Come First Serve

按照磁盘请求的顺序进行调度。优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

##### 最短寻道时间优先SSTF, Shortest Seek Time First

优先调度与当前磁头所在磁道距离最近的磁道。虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

##### 电梯算法SCAN

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。
电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。
因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。

### 链接

#### 编译系统

![](/img/post_pics/c/5.png)

- 预处理阶段：处理以 # 开头的预处理命令；
- 编译阶段：翻译成汇编文件；
- 汇编阶段：将汇编文件翻译成可重定向目标文件；
- 链接阶段：将可重定向目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。
  
#### 静态链接

静态链接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。
  
#### 目标文件

- 可执行目标文件：可以直接在内存中执行；

- 可重定向目标文件：可与其它可重定向目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定向目标文件，可以在运行时被动态加载进内存并链接；
  
#### 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。
  
共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。


## 想成为嵌入式程序员应知道的0x10个基本问题

这是嵌入式C程序员的基本知识。作者（`Jones Nigel`）在Embedded Systems Programming杂志上发表了很多嵌入式系统开发方面的文章。

C语言测试是招聘嵌入式系统程序员过程中必须而且有效的方法。这些年，我既参加也组织了许多这种测试，在这过程中我意识到这些测试能为面试者和被面试者提供许多有用信息，此外，撇开面试的压力不谈，这种测试也是相当有趣的。从被面试者的角度来讲，你能了解许多关于出题者或监考者的情况。这个测试只是出题者为显示其对ANSI标准细节的知识而不是技术技巧而设计吗？这是个愚蠢的问题吗？如要你答出某个字符的ASCII值。这些问题着重考察你的系统调用和内存分配策略方面的能力吗？这标志着出题者也许花时间在微机上而不是在嵌入式系统上。如果上述任何问题的答案是"是"的话，那么我知道我得认真考虑我是否应该去做这份工作。从面试者的角度来讲，一个测试也许能从多方面揭示应试者的素质：最基本的，你能了解应试者C语言的水平。不管怎么样，看一下这人如何回答他不会的问题也是满有趣。应试者是以好的直觉做出明智的选择，还是只是瞎蒙呢？当应试者在某个问题上卡住时是找借口呢，还是表现出对问题的真正的好奇心，把这看成学习的机会呢？我发现这些信息与他们的测试成绩一样有用。有了这些想法，我决定出一些真正针对嵌入式系统的考题，希望这些令人头痛的考题能给正在找工作的人一点帮助。这些问题都是我这些年实际碰到的。其中有些题很难，但它们应该都能给你一点启迪。这个测试适于不同水平的应试者，大多数初级水平的应试者的成绩会很差，经验丰富的程序员应该有很好的成绩。为了让你能自己决定某些问题的偏好，每个问题没有分配分数，如果选择这些考题为你所用，请自行按你的意思分配分数。

### 预处理器（Preprocessor）

- 用预处理指令#define 声明一个常数，用以表明1年中有多少秒（忽略闰年问题）

```cpp
#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL
```

我在这想看到几件事情：
>
> - #define 语法的基本知识（例如：不能以分号结束，括号的使用，等等）
> - 懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。
> - 意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。
> - 如果你在你的表达式中用到UL（表示无符号长整型），那么你有了一个好的起点。记住，第一印象很重要。

- 写一个"标准"宏MIN ，这个宏输入两个参数并返回较小的一个。

```cpp
#define MIN(A,B) （（A） <= (B) ? (A) : (B))
```

这个测试是为下面的目的而设的：
>
> - 标识#define在宏中应用的基本知识。这是很重要的。因为在  嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。
> - 三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优化的代码，了解这个用法是很重要的。
> - 懂得在宏中小心地把参数用括号括起来
> - 我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？least = MIN(*p++, b);
  
- 预处理器标识#error的目的是什么？
如果你不知道答案，请看参考文献1。这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出像这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。

### 死循环（Infinite loops）
  
-- 嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？
这个问题用几个解决方案。我首选的方案是：

```cpp
while(1){
}
```

一些程序员更喜欢如下方案：

```cpp
for(;;){
}
```

这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这个作为方案，我将用这个作为一个机会去探究他们这样做的基本原理。如果他们的基本答案是："我被教着这样做，但从没有想到过为什么。"这会给我留下一个坏印象。
第三个方案是用 goto

```cpp
Loop:
...
goto Loop;
```

应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。

### 数据声明（Data declarations）
  
- 用变量a给出下面的定义

> - 一个整型数（An integer）
> - 一个指向整型数的指针（ A pointer to an integer）
> - 一个指向指针的的指针，它指向的指针是指向一个整型数（ A pointer to a pointer to an intege）r
> - 一个有10个整型数的数组（ An array of 10 integers）
> - 一个有10个指针的数组，该指针是指向一个整型数的。（An array of 10 pointers to integers）
> - 一个指向有10个整型数数组的指针（ A pointer to an array of 10 integers）
> - 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）
> - 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）

答案是：
>
> - int a; // An integer
> - int *a; // A pointer to an integer
> - int **a; // A pointer to a pointer to an integer
> - int a[10]; // An array of 10 integers
> - int *a[10]; // An array of 10 pointers to integers
> - int [*a](10); // A pointer to an array of 10 integers
> - int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer
> - int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer

人们经常声称这里有几个问题是那种要翻一下书才能回答的问题，我同意这种说法。当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试 的时候，我期望被问到这个问题（或者相近的问题）。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案（或至少大部分答 案），那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么出准备呢？

### Static

- 关键字static的作用是什么？
这个简单的问题很少有人能回答完全。在C语言中，关键字static有三个明显的作用：
>
> - 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。
> - 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。
> - 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。

大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重要性。

### Const

- 关键字const有什么含意？
我 只要一听到被面试者说："const意味着常数"，我就知道我正在和一个业余者打交道。去年Dan Saks已经在他的文章里完全概括了const的所有用法，因此ESP(译者：Embedded Systems Programming)的每一位读者应该非常熟悉const能做什么和不能做什么.如果你从没有读到那篇文章，只要能说出const意味着"只读"就可 以了。尽管这个答案不是完全的答案，但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下Saks的文章吧。）
如果应试者能正确回答这个问题，我将问他一个附加的问题：
下面的声明都是什么意思？

```cpp
const int a;
int const a;
const int *a;
int * const a;
int const * a const;
```

前两个的作用是一样，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。第四个意思a是一个指向整型 数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数 是不可修改的，同时指针也是不可修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字const呢？我也如下的几下理由：
>
> - 关键字const的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理 其它人留下的垃圾，你就会很快学会感谢这点多余的信息。（当然，懂得用const的程序员很少会留下的垃圾让别人来清理的。）
> - 通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。
> - 合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。

### Volatile

- 关键字volatile有什么含意?并给出三个不同的例子。
一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子：
>
> - 并行设备的硬件寄存器（如：状态寄存器）
> - 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
> - 多线程应用中被几个任务共享的变量

回答不出这个问题的人是不会被雇佣的。我认为这是区分C程序员和嵌入式系统程序员的最基本的问题。搞嵌入式的家伙们经常同硬件、中断、RTOS等等打交道，所有这些都要求用到volatile变量。不懂得volatile的内容将会带来灾难。
假设被面试者正确地回答了这是问题（嗯，怀疑是否会是这样），我将稍微深究一下，看一下这家伙是不是直正懂得volatile完全的重要性。
>
> - 一个参数既可以是const还可以是volatile吗？解释为什么。
> - 一个指针可以是volatile 吗？解释为什么。  
  
下面的函数有什么错误：

```cpp
int square(volatile int *ptr)
{
    return *ptr * *ptr;
}
```

下面是答案：
>
> - 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。
> - 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。
  
这段代码有点变态。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：

```cpp
int square(volatile int *ptr)
{
    int a,b;
    a = *ptr;
    b = *ptr;
    return a * b;
}
```

由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：

```cpp
long square(volatile int *ptr)
{
    int a;
    a = *ptr;
    return a * a;
}
```

### 位操作（Bit manipulation）

- 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的bit 3，第二个清除a 的bit 3。在以上两个操作中，要保持其它位不变。
对这个问题有三种基本的反应：
>
> - 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。
> - 用bit fields。Bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon为其较复杂的通信芯片写的驱动程序，它用到了bit fields因此完全对我无用，因为我的编译器用其它的方式来实现bit fields的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。
> - 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。最佳的解决方案如下：

```cpp
#define BIT3 (0x1 << 3)
static int a;

void set_bit3(void)
{
    a |= BIT3;
}
void clear_bit3(void)
{
    a &= ~BIT3;
}
```

一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我希望看到几个要点：说明常数、|=和&=~操作。

### 访问固定的内存位置（Accessing fixed memory locations）

- 嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。
这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：

```cpp
    int *ptr;
    ptr = (int *)0x67a9;
    *ptr = 0xaa55;
```

一个较晦涩的方法是：

```cpp
    *(int * const)(0x67a9) = 0xaa55;
```

即使习惯于更接近第二种方案，但我建议你在面试时使用第一种方案。

### 中断（Interrupts）

- 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了__interrupt关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。

```cpp
__interrupt double compute_area (double radius)
{
    double area = PI * radius * radius;
    printf("\nArea = %f", area);
    return area;
}
```

这个函数有太多的错误了，以至让人不知从何说起了：
>
> - `ISR`不能返回一个值。如果你不懂这个，那么你不会被雇用的。
> - `ISR` 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。
> - 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短而有效率的，在ISR中做浮点运算是不明智的。
> - 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。

### 代码例子（Code examples）

- 下面的代码输出是什么，为什么？

```cpp
void foo(void)
{
    unsigned int a = 6;
    int b = -20;
    (a+b > 6) ? puts("> 6") : puts("<= 6");
}
```

这个问题测试你是否懂得C语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。不管如何，这无符号整型问题的答案是输出是 ">6"。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。 因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错 了这个问题，你也就到了得不到这份工作的边缘。

- 评价下面的代码片断：

```cpp
unsigned int zero = 0;
unsigned int compzero = 0xFFFF;
/*1's complement of zero */
```

对于一个`int型不是16位`的处理器为说，上面的代码是不正确的。应编写如下：

```cpp
unsigned int compzero = ~0;
```

这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程序员非常准确地明白硬件的细节和它的局限，然而PC机程序往往把硬件作为一个无法避免的烦恼。到了这个阶段，应试者或者完全垂头丧气了或者信心满满志在必得。如果显然应试者不是很好，那么这个测试就在这里结束了。但如果显然应试者做得不错，那么我就 扔出下面的追加问题，这些问题是比较难的，我想仅仅非常优秀的应试者能做得不错。提出这些问题，我希望更多看到应试者应付问题的方法，而不是答案。不管如 何，你就当是这个娱乐吧...

### 动态内存分配（Dynamic memory allocation）

- 尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？

这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已经在ESP杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？

```cpp
char *ptr;
if ((ptr = (char *)malloc(0)) == NULL)
    puts("Got a null pointer");
else
    puts("Got a valid pointer");
```

这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数malloc，得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输 出是"Got a valid pointer"。我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基 本原理更重要些。

### Typedef

- Typedef 在C语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：

```cpp
#define dPS struct s *
typedef struct s * tPS;
```

以上两种情况的意图都是要定义dPS 和 tPS 作为一个指向结构s指针。哪种方法更好呢？（如果有的话）为什么？
这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：typedef更好。思考下面的例子：

```cpp
dPS p1,p2;
tPS p3,p4;
```

第一个扩展为

```cpp
struct s * p1, p2;
```

上面的代码定义p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了p3 和p4 两个指针。

### 晦涩的语法

- C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？

```cpp
int a = 5, b = 7, c;
c = a+++b;
```

这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：

```cpp
c = a++ + b;
```

因此, 这段代码持行后a = 6, b = 7, c = 12。
如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题。

参考文献

1. Jones, Nigel, "In Praise of the #error directive," Embedded Systems Programming, September 1999, p. 114.
2. Jones, Nigel, " Efficient C Code for Eight-bit MCUs ," Embedded Systems Programming, November 1998, p. 66.
