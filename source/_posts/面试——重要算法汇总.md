---
layout: post
title: Leetcode主要算法汇总
date: 2024-01-19 16:52:57
tags: 
    - C/C++
    - 算法
categories: 
    - 面试
---

Leetcode题解汇总。统计到`NO.94`。

<!-- more -->

## 目录

- [目录](#目录)
- [链表](#链表)
  - [19. 删除链表的倒数第 N 个结点](#19-删除链表的倒数第-n-个结点)
  - [21. 合并两个有序链表](#21-合并两个有序链表)
  - [23. 合并 K 个升序链表](#23-合并-k-个升序链表)
  - [24. 两两交换链表中的节点](#24-两两交换链表中的节点)
  - [25. K 个一组翻转链表](#25-k-个一组翻转链表)
  - [61. 旋转链表](#61-旋转链表)
  - [82. 删除排序链表中的重复元素 II](#82-删除排序链表中的重复元素-ii)
  - [83. 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
  - [86. 分隔链表](#86-分隔链表)
  - [92. 反转链表 II](#92-反转链表-ii)
- [DFS](#dfs)
  - [22. 括号生成](#22-括号生成)
  - [39. 组合总和](#39-组合总和)
  - [40. 组合总和 II](#40-组合总和-ii)
  - [46. 全排列](#46-全排列)
- [动态规划](#动态规划)
  - [5. 最长回文子串](#5-最长回文子串)
  - [32. 最长有效括号](#32-最长有效括号)
  - [45. 跳跃游戏 II](#45-跳跃游戏-ii)
  - [53. 最大子数组和](#53-最大子数组和)
  - [55. 跳跃游戏](#55-跳跃游戏)
  - [62. 不同路径](#62-不同路径)
  - [63. 不同路径 II](#63-不同路径-ii)
  - [64. 最小路径和](#64-最小路径和)
  - [72. 编辑距离](#72-编辑距离)
  - [79. 单词搜索](#79-单词搜索)
- [二叉树](#二叉树)
  - [94. 二叉树的中序遍历](#94-二叉树的中序遍历)
- [字符串](#字符串)
  - [28. 找出字符串中第一个匹配项的下标（KMP）](#28-找出字符串中第一个匹配项的下标kmp)
  - [43. 字符串相乘](#43-字符串相乘)
  - [58. 最后一个单词的长度](#58-最后一个单词的长度)
  - [71. 简化路径](#71-简化路径)
  - [93. 复原 IP 地址](#93-复原-ip-地址)
- [数学](#数学)
  - [50. Pow(x, n)](#50-powx-n)
- [数组](#数组)
  - [48. 旋转图像](#48-旋转图像)
  - [54. 螺旋矩阵](#54-螺旋矩阵)
  - [56. 合并区间](#56-合并区间)
  - [66. 加一](#66-加一)
  - [85. 最大矩形](#85-最大矩形)
- [栈](#栈)
  - [20. 有效的括号](#20-有效的括号)
- [双指针](#双指针)
  - [11. 盛最多水的容器](#11-盛最多水的容器)
  - [26. 删除有序数组中的重复项](#26-删除有序数组中的重复项)
  - [27. 移除元素](#27-移除元素)
  - [31. 下一个排列](#31-下一个排列)
  - [42. 接雨水](#42-接雨水)
  - [75. 颜色分类](#75-颜色分类)
  - [80. 删除有序数组中的重复项 II](#80-删除有序数组中的重复项-ii)
- [哈希表](#哈希表)
  - [1. 两数之和](#1-两数之和)
  - [3. 无重复字符的最长子串](#3-无重复字符的最长子串)
- [二分](#二分)
  - [74. 搜索二维矩阵](#74-搜索二维矩阵)

## 链表

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
```

### 19. 删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* first = head;
        ListNode* second = dummy;
        for (int i = 0; i < n; ++i) {
            first = first->next;
        }
        while (first) {
            first = first->next;
            second = second->next;
        }
        second->next = second->next->next;
        ListNode* ans = dummy->next;
        delete dummy;
        return ans;
    }
};
```

### 21. 合并两个有序链表

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1){
            return list2;
        } else if(!list2){
            return list1;
        } else if(list1->val < list2->val){
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        } else {
            list2->next = mergeTwoLists(list2->next, list1);
            return list2;
        }
    }
};
```

### 23. 合并 K 个升序链表

给你一个链表数组，每个链表都已经按升序排列。
请你将所有链表合并到一个升序链表中，返回合并后的链表。

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1){
            return list2;
        } else if(!list2){
            return list1;
        } else if(list1->val < list2->val){
            list1->next = mergeTwoLists(list1->next, list2);
            return list1;
        } else {
            list2->next = mergeTwoLists(list2->next, list1);
            return list2;
        }
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* ret = nullptr;
        for (int i = 0; i < lists.size(); i++){
            ret = mergeTwoLists(ret, lists[i]);
        }
        return ret;
    }
};
```

### 24. 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if (head == nullptr || head->next == nullptr) {
            return head;
        }

        ListNode* tmp = head->next;
        head->next = swapPairs(tmp->next);
        tmp->next = head;
        return tmp;
    }
};
```

### 25. K 个一组翻转链表

给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。
k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode *head){
        ListNode* pre;
        ListNode* tmp;
        ListNode* cur = head;
        while(cur){
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        // 构造头节点
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;

        ListNode* end = dummy;
        ListNode* pre = dummy;

        int cnt = 0;
        while(end && end->next){
            // end是每k个的最后一个，从每一段的前一个开始向后，即idx[0] - 1
            // pre是每k个的第一个的前一个，更新后就是上一个end
            end = end->next;
            cnt += 1;

            if (cnt == k){
                cnt = 0;

                // next保存下一段的开头
                ListNode *next = end->next;
                // 这一段的开头是start
                ListNode* start = pre->next;
                // 这一段的结尾截断
                end->next = nullptr;

                // 反转后，start变为了最后一个
                pre->next = reverseList(start);
                start->next = next;

                // 更新pre，指向当前反转段的段尾
                pre = start;
                // 重新开始end
                end = pre;
            }
        }

        return dummy->next;
    }
};
```

### 61. 旋转链表

给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。

示例 1：

```bash
输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]
```

```cpp
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (k == 0 || head == nullptr || head->next == nullptr) {
            return head;
        }
        int n = 1;
        ListNode* iter = head;
        while (iter->next != nullptr) {
            iter = iter->next;
            n++;
        }
        int add = n - k % n;
        if (add == n) {
            return head;
        }
        iter->next = head;
        while (add--) {
            iter = iter->next;
        }
        ListNode* ret = iter->next;
        iter->next = nullptr;
        return ret;
    }
};
```

### 82. 删除排序链表中的重复元素 II

给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字。返回 已排序的链表。
示例 1：

```bash
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (!head) {
            return head;
        }
        
        ListNode* dummy = new ListNode(0, head);

        ListNode* cur = dummy;
        while (cur->next && cur->next->next) {
            if (cur->next->val == cur->next->next->val) {
                int x = cur->next->val;
                while (cur->next && cur->next->val == x) {
                    cur->next = cur->next->next;
                }
            }
            else {
                cur = cur->next;
            }
        }

        return dummy->next;
    }
};
```

### 83. 删除排序链表中的重复元素

给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

示例 1：

```bash
输入：head = [1,1,2]
输出：[1,2]
```

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* cur = head;
        while(cur){
            while (cur->next && cur->val == cur->next->val){
                cur->next = cur->next->next;
            }

            cur = cur->next;
        }

        return head;

    }
};
```

### 86. 分隔链表

给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。
你应当 保留 两个分区中每个节点的初始相对位置。

示例 1：

```bash
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

```cpp
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *smlDummy = new ListNode(0), *bigDummy = new ListNode(0);
        ListNode *sml = smlDummy, *big = bigDummy;
        while (head != nullptr) {
            if (head->val < x) {
                sml->next = head;
                sml = sml->next;
            } else {
                big->next = head;
                big = big->next;
            }
            head = head->next;
        }
        sml->next = bigDummy->next;
        big->next = nullptr;
        return smlDummy->next;
    }
};
```

### 92. 反转链表 II

给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。

示例 1：

```bash
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

```cpp
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int left, int right) {
        // 设置 dummyNode 是这一类问题的一般做法
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;
        ListNode *pre = dummyNode;
        for (int i = 0; i < left - 1; i++) {
            pre = pre->next;
        }
        ListNode *cur = pre->next;
        ListNode *next;
        for (int i = 0; i < right - left; i++) {
            next = cur->next;
            cur->next = next->next;
            next->next = pre->next;
            pre->next = next;
        }
        return dummyNode->next;
    }
};
```

## DFS

### 22. 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

```cpp
class Solution {
public:
    vector<string> res;
    void dfs(const string& str, int left, int right){
        if(left < 0 || left > right){
            return;
        }
        if(left == 0 && right == 0){
            res.push_back(str);
            return;
        }
        dfs(str + '(', left - 1, right);
        dfs(str + ')', left, right - 1);
    }
    vector<string> generateParenthesis(int n) {
        dfs("", n, n);
        return res;
    }
};
```

### 39. 组合总和

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
candidates 中的 同一个 数字可以 无限制重复被选取。如果至少一个数字的被选数量不同，则两种组合是不同的。
对于给定的输入，保证和为 target 的不同组合数少于 150 个。

示例 1：

```bash
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7。注意 2 可以使用多次。
7 也是一个候选， 7 = 7。
仅有这两种组合。
```

```cpp
class Solution {
public:
    void dfs(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& combine, int idx){
        if(idx == candidates.size()){
            return;
        }
        if(target == 0){
            ans.push_back(combine);
            return;
        }
        dfs(candidates, target, ans, combine, idx+1);

        if(target - candidates[idx] >= 0){
            combine.push_back(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> ans;
        vector<int> combine;
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }
};
```

### 40. 组合总和 II

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
candidates 中的每个数字在每个组合中只能使用 一次。
注意：解集不能包含重复的组合。

```bash
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

```cpp
class Solution {
private:
    vector<pair<int, int>> freq;
    vector<vector<int>> ans;
    vector<int> sequence;

public:
    void dfs(int pos, int rest) {
        if (rest == 0) {
            ans.push_back(sequence);
            return;
        }
        if (pos == freq.size() || rest < freq[pos].first) {
            return;
        }

        dfs(pos + 1, rest);

        int most = min(rest / freq[pos].first, freq[pos].second);
        for (int i = 1; i <= most; ++i) {
            sequence.push_back(freq[pos].first);
            dfs(pos + 1, rest - i * freq[pos].first);
        }
        for (int i = 1; i <= most; ++i) {
            sequence.pop_back();
        }
    }

    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end());
        for (int num: candidates) {
            if (freq.empty() || num != freq.back().first) {
                freq.emplace_back(num, 1);
            } else {
                ++freq.back().second;
            }
        }
        dfs(0, target);
        return ans;
    }
};

```

### 46. 全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列。你可以 按任意顺序 返回答案。
示例 1：

```bash
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

```cpp
class Solution {
public:
    void dfs(vector<vector<int>>& res, vector<int>& nums, int idx, int len){
        if (idx == len){
            res.push_back(nums);
            return;
        }

        for (int i = idx; i < len; i++){
            swap(nums[i], nums[idx]);
            dfs(res, nums, idx + 1, len);
            swap(nums[i], nums[idx]);
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        dfs(res, nums, 0, int(nums.size()));

        return res;

    }
};
```

## 动态规划

### 5. 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
示例 1：

```bash
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2){
            return s;
        }

        int max_len = 1;
        int idx = 0;
        vector<vector<int>> dp(n, vector<int>(n));

        for(int i = 0; i < n; i++){
            dp[i][i] = 1;
        }

        for(int L = 2; L <=n; L++){
            for(int i = 0; i < n; i++){
                int j = L + i -1;
                if(j >= n){
                    break;
                }

                if(s[i] != s[j]){
                    dp[i][j] = 0;
                } else {
                    if (j - i < 3){
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i+1][j-1];
                    }
                }

                if(dp[i][j] == 1 && L > max_len){
                    max_len = L;
                    idx = i;
                }
            }
        }

        return s.substr(idx, max_len);
    }
};
```

### 32. 最长有效括号

给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
示例 1：

```bash
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        int maxans = 0, n = s.length();
        vector<int> dp(n, 0);
        for (int i = 1; i < n; i++) {
            if (s[i] == ')') {
                if (s[i - 1] == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = max(maxans, dp[i]);
            }
        }
        return maxans;
    }
};
```

### 45. 跳跃游戏 II

给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

0 <= j <= nums[i]
i + j < n
返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();

        if (n == 1){
            return 0;
        }
        vector<int> dp(n, INT_MAX);

        dp[0] = 0;
        for(int i = 0; i < n; i++){
            for (int j = 1; j <= nums[i] && i + j < n; j++){
                dp[i + j] = min(dp[i+j], dp[i] + 1);
            }
        }
        return dp[n-1];
    }
};
```

### 53. 最大子数组和

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。

示例 1：

```bash
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        int ret;
        vector<int> dp(n);

        if (n == 1){
            return nums[0];
        }

        dp[0] = nums[0];
        ret = dp[0];
        for (int i = 1; i < n; i++){
            dp[i] = max(dp[i-1] + nums[i], nums[i]);
            ret = max(ret, dp[i]);
        }

        return ret;
    }
};
```

### 55. 跳跃游戏

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false。

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int max_jump = 0;

        if (n == 1){
            return true;
        }
        for (int i = 0; i < n - 1; i++){
            if (i <= max_jump){
                max_jump = max(max_jump, i + nums[i]);
            }
        }
        return max_jump >= n-1;
    }
};
```

### 62. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<int> dp(n);
        dp[0] = 1;
        for (int j = 0; j < m; j ++){
            for (int i = 0; i < n ; i++){
                if (j == 0 && i > 0){
                    dp[i] = 1;
                }
                if (i == 0 && j > 1){
                    dp[i] = 1;
                }
                if(i > 0 && j > 0){
                    dp[i] = dp[i] + dp[i-1];
                }
            }
        }
        return dp[n-1];
    }
};
```

### 63. 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int n = obstacleGrid.size(), m = obstacleGrid.at(0).size();
        vector <int> f(m);

        f[0] = (obstacleGrid[0][0] == 0);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {
                    f[j] += f[j - 1];
                }
            }
        }

        return f.back();
    }
};
```

### 64. 最小路径和

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。

示例 1：

```bash
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> dp(n);
        for (int i = 0; i < m; i++){
            for (int j = 0; j < n; j++){
                if (i == 0){
                    if(j == 0){
                        dp[j] = grid[0][0];
                    } else{
                        dp[j] = dp[j-1] + grid[i][j];
                    }
                } else {
                    if (j == 0){
                        dp[j] += grid[i][0];
                    } else {
                        dp[j] = min(dp[j], dp[j-1]) + grid[i][j];
                    }
                }
            }
        }
        return dp[n-1];
    }
};
```

### 72. 编辑距离

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符

示例 1：

```bash
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

示例 2：

```bash
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.length(), m = word2.length();

        if (m * n == 0){
            return m + n;
        }

        vector<vector<int>> dp(n+1, vector<int>(m+1));
        for(int i = 0; i <= n; i++){
            dp[i][0] = i;
        }
        for(int j = 0; j <= m; j++){
            dp[0][j] = j;
        }
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= m; j++){
                int ans1 = dp[i][j-1] + 1;
                int ans2 = dp[i-1][j] + 1;
                int ans3 = dp[i-1][j-1];
                if (word1[i-1] != word2[j-1]){
                    ans3 +=1;
                }
                dp[i][j] = min(ans1, min(ans2, ans3));
            }
        }
        return dp[n][m];
    }
};
```

### 79. 单词搜索

给定一个 m x n 二维字符网格 board 和一个字符串单词 word。如果 word 存在于网格中，返回 true ；否则，返回 false。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

```bash
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

```cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        rows = board.size();
        cols = board[0].size();
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < cols; j++) {
                if (dfs(board, word, i, j, 0)) return true;
            }
        }
        return false;
    }
private:
    int rows, cols;
    bool dfs(vector<vector<char>>& board, string word, int i, int j, int k) {
        if (i >= rows || i < 0 || j >= cols || j < 0 || board[i][j] != word[k]) return false;
        if (k == word.size() - 1) return true;
        board[i][j] = '\0';
        bool res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
};
```

## 二叉树

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
```

### 94. 二叉树的中序遍历

给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。

```cpp
class Solution {
public:
    void inorder(TreeNode* root, vector<int>& res){
        if (!root){
            return;
        }
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }
};
```

## 字符串

### 28. 找出字符串中第一个匹配项的下标（KMP）

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1。

```cpp
class Solution {
public:
    int strStr(string s, string p) {
        int n = s.size(), m = p.size();
        if(m == 0) return 0;
        //设置哨兵
        s.insert(s.begin(),' ');
        p.insert(p.begin(),' ');
        vector<int> next(m + 1);
        //预处理next数组
        for(int i = 2, j = 0; i <= m; i++){
            while(j and p[i] != p[j + 1]) j = next[j];
            if(p[i] == p[j + 1]) j++;
            next[i] = j;
        }
        //匹配过程
        for(int i = 1, j = 0; i <= n; i++){
            while(j and s[i] != p[j + 1]) j = next[j];
            if(s[i] == p[j + 1]) j++;
            if(j == m) return i - m;
        }
        return -1;
    }
};

```

### 43. 字符串相乘

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。
注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if ((num1.size() == 1 && num1[0] == '0') || (num2.size() == 1 && num2[0] == '0')){
            return "0";
        }
        int n = num1.size(), m = num2.size();
        vector<int> ans(n * m + 1, 0);
        string long_num, short_num;

        if (n > m){
            long_num = num1;
            short_num = num2;
        } else {
            long_num = num2;
            short_num = num1;
        }
        n = long_num.size();
        m = short_num.size();
        for (int i = m - 1; i >= 0; i--){
            for (int j = n - 1; j >= 0; j--){
                int cur = (long_num[j] - '0') * (short_num[i] - '0');
                ans[m-1-i + n-1-j] += cur;
            }
        }

        string ret;
        int add = 0;
        for (int i = 0; i < m * n + 1; i++){
            ret += (ans[i] + add) % 10 + '0';
            add = (ans[i] + add) / 10;
        }

        reverse(ret.begin(), ret.end());

        string res;
        for (int i = 0; i < ret.size(); i++){
            if (ret[i] != '0'){
                for (int j = i; j < ret.size(); j++){
                    res += ret[j];
                }
                break;
            }
            
        }
        return res;
    }
};
```

### 58. 最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

```cpp
class Solution {
public:
    int lengthOfLastWord(string s) {
        int n = s.size();
        string ret = "";
        int idx = 0;
        for (int i = n - 1; i >= 0; i--){
            if (s[i] != ' '){
                idx = i;
                break;
            }
        }
        for (int i = idx; i >= 0; i --){
            if (s[i] == ' '){
                break;
            }
            ret += s[i];
        }
        return ret.size();

    }
};
```

### 71. 简化路径

给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/'。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/'。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径。

示例 1：

```bash
输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。
```

示例 2：

```bash
输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。
```

示例 3：

```bash
输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。
```

示例 4：

```bash
输入：path = "/a/./b/../../c/"
输出："/c"
```

```cpp
class Solution {
public:
    string simplifyPath(string path) {
        int n = path.size();
        string ret = "", cur = "";
        vector<string> ans, strs;

        if (n == 1) return "/";

        //截断输入
        for (int i = 1; i < n; i++){
            if (path[i] != '/'){
                cur += path[i];
            } else {
                strs.push_back(cur);
                cur = "";
            }
        }

        //注意最后一个子串
        if (cur.size() > 0) strs.push_back(cur);

        for (int i = 0; i < strs.size(); i++){
            // 处理 '..'
            if (strs[i].size() == 2 && strs[i] == ".."){
                if(ans.size() > 0){
                    ans.pop_back();
                }
            } else if (strs[i] == "" || strs[i] == "."){
                // 连续的'//'会出现空子串，'.'应当忽略
                continue;
            } else {
                ans.push_back(strs[i]);
            }
        }

        // 没有有效的子串则返回'/'
        if(ans.size() == 0) return "/";

        for (int i = 0; i < ans.size(); i++){
            ret += "/" + ans[i];
        }

        return ret;
    }
};
```

### 93. 复原 IP 地址

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

示例 1：

```bash
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

```cpp
class Solution {
public:
    void dfs(string s, vector<string>& res, string& ip, int count){
        int n = s.size();
        if(count == 0){
            if (n > 0){
                if (n == 1 || (n >= 1  && n <= 3 && (s[0] != '0') && stoi(s) <= 255)){
                    ip += s;
                    res.push_back(ip);
                }
            }
            return;
        }
        if (n == 0){
            return;
        }
        
        string next_ip;
        next_ip = ip + s[0] + '.';
        dfs(s.substr(1, n - 1), res, next_ip, count - 1);

        if(s[0] != '0'){
            if (n >= 2){
                next_ip = ip + s.substr(0, 2) + '.';
                dfs(s.substr(2, n - 2), res, next_ip, count - 1);
            }
            if (n >= 3){
                if (stoi(s.substr(0, 3)) <= 255){
                    next_ip = ip + s.substr(0, 3) + '.';
                    dfs(s.substr(3, n - 3), res, next_ip, count - 1);
                }
            }
        }
    }

    vector<string> restoreIpAddresses(string s) {
        vector<string> res;
        string ip;
        dfs(s, res, ip, 3);

        return res;
    }
};
```

## 数学

### 50. Pow(x, n)

实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。

```cpp
class Solution {
public:
    double quickMul(double x, long long n) {
        double ans = 1.0;
        double tmp = x;
        while(n > 0){
            if (n % 2 == 1){
                ans *= x;
            }

            x *= x;
            n /= 2;
        }
        return ans;
    }
    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
};
```

## 数组

### 48. 旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
};
```

### 54. 螺旋矩阵

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector <int> ans;
        if(matrix.empty()) return ans; //若数组为空，直接返回答案
        int u = 0; //赋值上下左右边界
        int d = matrix.size() - 1;
        int l = 0;
        int r = matrix[0].size() - 1;
        while(true)
        {
            for(int i = l; i <= r; ++i) ans.push_back(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(int i = u; i <= d; ++i) ans.push_back(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(int i = r; i >= l; --i) ans.push_back(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(int i = d; i >= u; --i) ans.push_back(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
    }
};
```

### 56. 合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi]。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

示例 1：

```bash
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) {
            return {};
        }
        sort(intervals.begin(), intervals.end());
        vector<vector<int>> merged;
        for (int i = 0; i < intervals.size(); ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (!merged.size() || merged.back()[1] < L) {
                merged.push_back({L, R});
            }
            else {
                merged.back()[1] = max(merged.back()[1], R);
            }
        }
        return merged;
    }
};
```

### 66. 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1：

```bash
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        reverse(digits.begin(), digits.end());
        int n = digits.size();
        int c = 0;
        for (int i = 0; i < n; i ++){
            if (i == 0){
                digits[0] += 1;
            }
            int cur = (digits[i] + c) % 10;
            c = (digits[i] + c)/ 10;
            digits[i] = cur;
        }
        if (c > 0){
            digits.push_back(c);
        }
        reverse(digits.begin(), digits.end());
        return digits;
    }
};
```

### 85. 最大矩形

给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例 1：

```bash
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size();
        if (m == 0) {
            return 0;
        }
        int n = matrix[0].size();
        vector<vector<int>> left(m, vector<int>(n, 0));

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0: left[i][j - 1]) + 1;
                }
            }
        }

        int ret = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '0') {
                    continue;
                }
                int width = left[i][j];
                int area = width;
                for (int k = i - 1; k >= 0; k--) {
                    width = min(width, left[k][j]);
                    area = max(area, (i - k + 1) * width);
                }
                ret = max(ret, area);
            }
        }
        return ret;
    }
};
```

## 栈

### 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
每个右括号都有一个对应的相同类型的左括号。

```cpp
class Solution {
public:
    bool isValid(string s) {
        int n = s.size();
        stack<char> st;
        for (int i = 0; i < n; i++){
            if (!st.empty() && ((st.top() == '{' && s[i] == '}') || (st.top() == '(' && s[i] == ')') || (st.top() == '[' && s[i] == ']'))){
                st.pop();
            } else {
                st.push(s[i]);
            }
        }

        return st.empty();
    }
};
```

## 双指针

### 11. 盛最多水的容器

给定一个长度为 n 的整数数组 height。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i])。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ret = 0;
        int n = height.size();
        int left = 0, right = n - 1;
        while (left < right){
            ret = max(ret, min(height[right], height[left]) * (right - left));
            if (height[right] > height[left]){
                left ++;
            } else {
                right --;
            }
        }
        return ret;
    }
};
```

### 26. 删除有序数组中的重复项

给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致。然后返回 nums 中唯一元素的个数。

考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：

更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
返回 k。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int fast = 1, slow = 1;
        while (fast < n) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
};
```

### 27. 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int n = nums.size();
        int left = 0;
        for (int right = 0; right < n; right++) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
        }
        return left;
    }
};
```

### 31. 下一个排列

整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2]。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2]。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        while (i >= 0 && nums[i] >= nums[i+1]){
            i--;
        }

        if (i >= 0){
            int j = nums.size() - 1;
            while(j > i && nums[i] >= nums[j]){
                j--;
            }
            swap(nums[i], nums[j]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

### 42. 接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例 1：

```bash
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）
```

```cpp
class Solution {
public:
    int cal_water(vector<int>& height, int left, int right){
        int ret = min(height[left], height[right]) * (right - left - 1);
        int sum = 0;
        for (int i = left + 1; i <= right - 1; i++){
            sum += height[i];
        }
        return ret - sum;

    }
    int trap(vector<int>& height) {
        int n = height.size();
        int ret = 0;
        int r = 1;
        int max_h = height[0], max_h_idx = 0;

        if (n == 1){
            return 0;
        }

        while(max_h_idx <= r && r < n){
            if (height[r] >= max_h){
                ret += cal_water(height, max_h_idx, r);
                max_h = height[r];
                max_h_idx = r;
            }

            r++;
        }

        max_h = height[n-1];
        max_h_idx = n-1;
        r = n-2;
        while(r <= max_h_idx && r >= 0){
            if (height[r] > max_h){
                ret += cal_water(height, r, max_h_idx);
                max_h = height[r];
                max_h_idx = r;
            }

            r--;
        }

        return ret;
    }
};
```

### 75. 颜色分类

给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
必须在不使用库内置的 sort 函数的情况下解决这个问题。

示例 1：

```bash
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int n = nums.size();

        int red = 0, blue = n - 1;
        for (int i = 0; i < n; i ++){
            if (nums[i] == 0){
                swap(nums[red], nums[i]);
                red ++;
            }
        }

        for (int i = n - 1; i >= 0; i --){
            if (nums[i] == 2){
                swap(nums[blue], nums[i]);
                blue --;
            }
        }
    }
};
```

### 80. 删除有序数组中的重复项 II

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        if (n <= 2) {
            return n;
        }
        int slow = 2, fast = 2;
        while (fast < n) {
            if (nums[slow - 2] != nums[fast]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
};
```

## 哈希表

### 1. 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。

示例 1：

```bash
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回[0, 1]。
```

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); i++) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()){
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```

### 3. 无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0) return 0;
        unordered_set<char> lookup;
        int maxStr = 0;
        int left = 0;
        for(int i = 0; i < s.size(); i++){
            while (lookup.find(s[i]) != lookup.end()){
                lookup.erase(s[left]);
                left ++;
            }
            maxStr = max(maxStr,i-left+1);
            lookup.insert(s[i]);
        }
        return maxStr;
        
    }
};
```

## 二分

### 74. 搜索二维矩阵

给你一个满足下述两条属性的 m x n 整数矩阵：

每行中的整数从左到右按非严格递增顺序排列。
每行的第一个整数大于前一行的最后一个整数。
给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false。

```bash
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

```cpp
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int low = 0, high = m * n - 1;
        while (low <= high) {
            int mid = (high - low) / 2 + low;
            int x = matrix[mid / n][mid % n];
            if (x < target) {
                low = mid + 1;
            } else if (x > target) {
                high = mid - 1;
            } else {
                return true;
            }
        }
        return false;
    }
};
```
